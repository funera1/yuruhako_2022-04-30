# 5分でわから構文解析
2022/04/30

---

# 自己紹介
- 公立はこだて未来大学　3年 高度ICTコース
- 競技プログラミング
- twitter: fun_7776
- 趣味
  - キャンプ
  - 神椿
  - Vtuber

---

# 自作言語
- 自作言語やってるよ
- コンパイラってフロントエンドとバックエンドからなるよ
  - フロントとバックについての説明をしたい
- 今回はフロントエンドに着目するよ（バックエンドまだできてなくてもなんもわからん...)

---

# フロントエンド
## だいたいの流れ
ソースコード->字句解析->構文解析->抽象構文木
フロントエンドのメインの処理が構文解析

---

# 構文解析
- 構文解析ってなんのためにするの？
  - 入力が規則を満たしているかの確認
  - ASTに変換するための準備

--- 

# LL(1)法
## どういうアルゴリズム？
- トップダウン式
- バックトラッキングしない
- 左端導出
- 実装が簡単でよく使われている(wiki)
  - とはいえ、実際実装してみて結構辛かった。

---

# LL(1)法
## もっと具体的に
### まずトップダウンの説明
トップダウン式の構文解析は(例を見せる)
- A-> B | C
- B-> aC | bC
- C-> b
入力xがあたえられたときに、xが規則を満たしているかをAを規則のスタートとしたときにAから変換させていき、一致しているかを調べていく方式です。またab->Bといったふうに、下から見ていくのをボトムアップ方式といいます。
木を見せるのが早そう

---

# LL(1)法
## もっと具体的に
### LL(1)法のアルゴリズム
愚直にやるとバックトラッキングが起きてしまう。入力を先読みして（k個先読みでLL(k)法)、バックトラッキングが起きないように変換していこう。
その変換表を作るのが目的で、その表を作るために、FIRST集合とFOLLOW集合を持つ。それらを使ってバックトラッキングが起きないような表を作る

# LL(1)法
## 嬉しくない点
- 1つしか先読みしないので、構文解析できる能力が低い
- 左端導出なので、左再帰するような規則を排除しなければならない。
  - たとえば、A -> Aaといった規則は A -> A'

# まとめ
