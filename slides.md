---
theme: bricks
colorSchema: 'auto'
download: true
---

# 5分でわからない構文解析
2022/04/30

---

# 自己紹介
- 公立はこだて未来大学　3年 高度ICTコース
- twitter: @fun_7776
- 趣味
  - キャンプ(予定)
  - Vtuber

---

# 自作言語
- 自作言語やってるよ
  - フルスクラッチで書きたいね
  - https://github.com/funera1/mylang

--- 

# コンパイラについて
- コンパイラってフロントエンドとバックエンドからなるよ
- 今回はフロントエンドに着目するよ（バックエンドまだできてなくてもなんもわからん...)

---

# フロントエンド
## だいたいの流れ
ソースコード -> 字句解析 -> トークン列 -> 構文解析 -> 具象構文木(CST) -> 抽象構文木(AST)
- フロントエンドのメインの処理が構文解析

---

# 構文解析
- 構文解析ってなんのためにするの？
  - 入力が規則を満たしているかの確認
  - ASTに変換するための準備

--- 

# 構文解析
## 入力が規則を満たしているかの確認

- 規則
```
  PROGRAM -> int main { COMPOUND }
  COMPOUND -> STATEMENT COMPOUND | ε
  STATEMENT -> int a; | a = 10;
```

があり、入力
```c
int main {
  int a;
  a = 10;
}
```
があたえられたときに、上の規則を満たしているかを確認する。

---

# 構文解析
## ASTに変換するための準備
- 文字列で持っていると単純に実装上不便
- ソースコードの意味のない部分を取り除く
  - {}や;はそれ自体に意味はない。それが示している意味は木構造で表せる。
- 数式は木にしたほうが計算しやすい。逆ポーランド法など

---

# 構文解析
```
PROGRAM
|
V
int main { COMPOUND }
           |
           +---------+
           |         |
           V         V
           STATEMENT COMPOUND
           |         |
           +----+-+  |
           |    | |  |
           V    V V  +----------+
           int  a ;  |          |
                     V          V
                     STATEMENT  COMPOUND
                     |          |
                     +-+-+--+   |
                     | | |  |   |
                     V V V  V   V
                     a = 10 ;   ε
```

---

# LL(1)法
- 終端記号と非終端記号の組み合わせに変換を対応づける
- それをするために,FIRST集合とFOLLOW集合を用意する

---

# LL(1)法
- FIRST集合
  - 非終端記号Xにおいて、Xからn回変換し初めて現れた終端記号の集合

- FOLLOW集合
  - 非終端記号Xにおいて、Xの隣の記号Aについて、FIRST(A)の和集合。ただし、終端記号aにおいて、FIRST(a) = {a}とする。

---

# まとめ
- 入力が規則を満たしているかの確認
- ASTに変換するための準備
- 愚直な解き方だとめちゃくちゃ時間かかる
- LL法などのアルゴリズムを使うと多項式時間で解ける